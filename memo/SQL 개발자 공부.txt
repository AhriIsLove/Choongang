●●●●●●●●●필기●●●●●●●●●
○ 데이터 모델링
1. 개념적 데이터 모델링
- 추상화
- 엔티티(테이블) 정의
-- 엔티티간 관계 정의
- 개념 ERD
2. 논리적 데이터 모델링
- 엔티티 구체화
-- 칼럼 정의
-- PK, FK 정의
-- 엔티티간 관계 구체화
- 정규화
- 논리 ERD
3. 물리적 데이터 모델링
- 성능 최적화(Index)
- 물리 ERD
- 스키마 정의

○ 엔티티 : 테이블
○ 인스턴스 : 테이블 행
○ 속성 : 칼럼

○ 슈퍼타입/서브타입 : 슈퍼타입과 서브타입은 상속 관계를 가지는 테이블 타입
- ONE TO ONE : 서브테이블의 PK가 FK인경우
- PLUS TYPE : 서브테이블의 PK와 FK가 따로 있는 경우
- SINGLE TYPE : 슈퍼테이블과 서브테이블을 병합하는 경우

○ 정규화
- 제1정규화 : 값들을 원자값(Atomic Value)으로 설정
- 제2정규화 : PK를 단일 속성으로 설정
- 제3정규화 : PK가 아닌 속성들의 종속 제거
- BCNF : 후보키가 아닌 속성이 다른 속성과 종속된 경우 제거
- 제4정규화 : 다중 종속, 다치 종속 제거
- 제5정규화 : 결합 종속, 조인 종속 제거

○ 엔티티
- 독립 엔티티 : 사람, 물건, 장소 등과 같이 현실세계에 존재하는 엔터티
- 업무중심 엔티티 : Transaction이 실행되면서 발생하는 엔터티
- 종속 엔티티 : 주로 1차 정규화로 인해 관련 중심엔티티로부터 분리된 엔터티
- 교차 엔티티 : M:M의 관계를 해소하려는 목적으로 만들어진 엔터티 [ex> M:M -> 1:M]

○ 관계
- 식별관계(실선) : 부모 테이블의 기본키 또는 유니크 키를 자식 테이블이 자신의 기본키로 사용
- 비식별관계(점선) : 부모 테이블의 기본키 또는 유니크 키를 자신의 기본키로 사용하지 않고, 외래 키로 사용하는 관계 (약한 연결관계)

○ 관계차수 : 두 엔티티간의 관계에서 참여자의 수

유형 엔티티 : 업무에서 도출되며 지속적으로 사용되는 Entity
개념 엔티티 : 개념적으로 사용되는 Entity
- 유형 엔터티는 물리적 형태가 있지만, 개념 엔터니는 물리적 형태가 없다
사건 엔티티 : 비즈니스 프로세스를 실행하면서 생성되는 Entity

기본 엔티티 : 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티, 키 엔터티[Key Entity]라고도 함
중심 엔티티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 엔터티
행위 엔티티 : 2개 이상의 엔터티로부터 발생하는 엔터티, 지속적으로 정보가 추가되고 변경되는 엔터티

○ Attribute(속성)
- 기본 속성 : 업무 분석을 통해 원래부터 존재하는 속성
-- 회원 번호
- 설계 속성 : 데이터 모델링 과정에서 인위적으로 만들거나 추가하는 속성
-- 회원 등급(보통 저장함)
- 파생 속성 : 다른 속성들의 값으로부터 계산되거나 파생되어 나오는 속성
-- 가입일수(보통 그때그때 계산함)

- 일반 속성 : PK, FK외 나머지
- PK 속성 : PK
- FK 속성 : FK

○ 식별자
- 대표성여부
-- 주식별자 : PK
-- 보조식별자 : 후보키

- 스스로생성여부
-- 내부식별자 : PK,후보키
-- 외부식별자 : FK

- 속성의 수
-- 단일식별자 : 단일속성 키
-- 복합식별자 : 슈퍼키

- 대체여부
-- 본질식별자 : 업무(비즈니스)에 의해 만들어지는 식별자
-- 인조식별자 : 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자(ex. 주문엔터티의 주문번호(고객번호+주문번호+순번))

○ 스키마
- 외부스키마(서브스키마) : 사용자 개개인의 관점에서의 데이터베이스
- 개념스키마 : 데이터베이스가 물리적으로 어떻게 저장되는지를 정의
- 내부스키마 : 데이터베이스 전체의 논리적인 구조

○ 분산 데이터베이스
- 장점
-- 신뢰성, 가용성이 높다
-- 병렬처리 하여 빠르다
-- 용량확장이 쉽다.

- 단점
-- 관리 통제가 어렵다
-- 무결성 관리가 어렵다
-- 보안이 취약하다
-- 설계가 복잡하다

○ 조인
- Hash JOIN : =로 수행하는 조인으로 동등조건에만 사용 가능
- Cross JOIN : SELECT * FROM A, B;
- Nested Loop JOIN : 중첩 루프 조인
-- 적은 데이터를 조인할 때 유리한 구조
-- 온라인 트랜잭션 처리(OLTP)에 유용
-- 랜덤 방식으로 엑세스 한다.
-- 먼저 선행 테이블의 조건을 만족하는 행을 추출하여 후행 테이블을 읽으면서 조인을 수행한다.

○ ROLE : 권한 묶음
- DBA, CONNECT, RESOURCE

○ 성능을 고려한 데이터모델링 순서
- 데이터 모델링을 할 때 정규화를 정확하게 수행
- 데이터베이스 용량산정 수행
- 데이터베이스에 발생되는 트랜잭션 유형 파악
- 용량과 트랜잭션의 유형에 따라 반정규화 수행
- 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 수행
- 성능관점에서 데이터 모델 검증

○ 윈도우함수 : 각 행에 대하여 계산하는 함수(OVER 범위지정 필요)

○ 테이블 파티션 분할
- Range Partition(범위 분할) : 범위를 기준으로 분할
- List Partition(목록 분할) : 여러 값을 기준으로 분할
- Hash Partition(해시 분할) : 데이터 관리보다 성능향상을 위해 해시 함수 값을 이용하여 분할한다
- Composite Partition(합성 분할) : 여러 기법을 결합하여 분할한다
- Round Robin(라운드로빈) : 균등하게 분할한다.

○ ERD 표기법
- I/E : 주식별자를 영역으로 구분
- Barker : 주식별자를 #으로 구분
- IDEFIX : 관계를 나타내는 선에 까치발같은게 없음...
- Peter Chen : 순서도처럼(사각형/마름모/타원) 표기

●●●●●●●●●실기●●●●●●●●●
○ RANK : 순위매기기
- RANK : 1, 2, 2, 4
- DENSE_RANK : 1, 2, 2, 3
- ROW_NUMBER : 1, 2, 3, 4
- NTILE(N) : 수능등급매기기(최대N)

○ COALESCE : NULL 값이 아닌 첫번째 값을 반환한다

○ 트리(계층구조)만들기
- START WITH col1 = v1 CONNECT BY PRIOR col1 = col2
- ORDER SIBLINGS BY : 계층 구조를 유지하며 정렬

○ 집계(GROUP BY ~ HAVING ~)
- GROUP BY ROLLUP(col1, col2) : 그룹별 집계 + total집계를 보여준다.
- GROUP BY CUBE(col1, col2) : 표현 가능한 모든 조합의 그룹별 집계를 보여준다.
- GROUP BY GROUPING SET((col1, col2), col3) : 파라미터에 해당되는 그룹별 집계만 보여준다.

○ INDEX SCAN
- INDEX UNIQUE SCAN : 1개 찾으면 끝
- INDEX RANGE SCAN : 범위 검색
- INDEX FULL SCAN : 전체 검색
-- DESCENDING : 역방향 검색

○ 서브쿼리
- CORRELATED 서브쿼리(상호연관 서브쿼리) : 서브쿼리 결과를 메인쿼리가 = 로 비교
- EARLY FILTER형 서브쿼리 : 서브쿼리 결과를 메인쿼리가 범위로 비교

○ 다른행 출력
LAG : 이전 행의 값을 리턴
- LAG(col1, 1) : 바로 이전 행의 col1값
LEAD : 다음 행의 값을 리턴
- LEAD(col1, 2) : 다음다음 행의 col1값

○ NULL처리함수
- NVL(값, 0) : 값이 null이면 0, 아니면 값
- NVL2(값, 1, 0) : 값이 null이면 0, 아니면 1
- COALESCE(값1, 값2)
-- 값1이 null이 아니면 값1
-- 값1이 null이고 값2가 null이 아니면 값2
-- 값1, 값2가 모두 null이면 null
- NULLIF(값1, 값2) : 값1, 값2가 같으면 null, 다르면 값1

- NULLS LAST : ORDER BY 절에서 null값이 있으면 마지막에 보여준다.
- NULLS FIRST : ORDER BY 절에서 null값이 있으면 첫행에 보여준다.(Default)

○ CURSOR
- CURSOR DECLARE : 선언
- CURSOR OPEN : 시작
- CURSOR FETCH : 진행
- CURSOR CLOSE : 종료

●●●●●●●●●쿼리 팁●●●●●●●●●
○ 특수문자 '_'가 포함된 항목 찾기
SELECT * FROM TEST WHERE NAME LIKE '%@_%' ESCAPE '@';
LIKE 연산으로 '%' 나 '_' 등과 같은 특수문자를 검색하기 위해서는 위와 같이 ESCAPE 를 사용해주어야만 합니다.

○ IN (NULL, col1)
col1에 해당하는 값들만 출력한다.

○ NOT IN (NULL, col1)
col1에 해당하지 않는 값에 상관없이 아무것도 출력하지 않는다.

○ 서브쿼리 제한조건
- WHERE col1 = 서브쿼리X
- WHERE col1 IN 서브쿼리
- WHERE col1 EXISTS 서브쿼리X
○ 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다.

○ ALL 연산자 : 사용하기 위해 비교연산자가 필수
WHERE col1 > ALL (서브쿼리)

○ UNION/UNION ALL를 사용할 때 나오는 SQL문은 칼럼 수와 데이터 타입이 완전 일치해야 함

○ OVER
- ORDER BY col
- PARTITION BY col
- RANGE BETWEEN (UNBOUNDED/n) PRECEDING AND (UNBOUNDED/n) FOLLOWING

